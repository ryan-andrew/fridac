"""Auto-generated file. Run tools/embed_shim.py to regenerate."""

SHIM_JS = "const _global = typeof globalThis !== 'undefined' ? globalThis : global;\n\nif (!_global.Module) _global.Module = {};\nif (!_global.Memory) _global.Memory = {};\nif (!_global.Process) _global.Process = {};\nif (!_global.Thread) _global.Thread = {};\nif (!_global.Kernel) _global.Kernel = {};\n\nif (typeof _global.Interceptor === 'undefined' && _global.Gum && _global.Gum.Interceptor) {\n    _global.Interceptor = _global.Gum.Interceptor;\n    _global.Stalker = _global.Gum.Stalker;\n    _global.NativeFunction = _global.Gum.NativeFunction;\n    _global.NativeCallback = _global.Gum.NativeCallback;\n}\n\nconst originalModule = _global.Module;\n\nif (typeof originalModule.findExportByName !== 'function') {\n    originalModule.findExportByName = function(moduleName, exportName) {\n        if (moduleName === null) {\n            return originalModule.findGlobalExportByName(exportName);\n        }\n        try {\n            const mod = Process.getModuleByName(moduleName);\n            return mod ? mod.findExportByName(exportName) : null;\n        } catch (e) {\n            return null;\n        }\n    };\n}\n\nif (typeof originalModule.getExportByName !== 'function') {\n    originalModule.getExportByName = function(moduleName, exportName) {\n        if (moduleName === null) {\n            return originalModule.getGlobalExportByName(exportName);\n        }\n        try {\n            const mod = Process.getModuleByName(moduleName);\n            return mod ? mod.getExportByName(exportName) : null;\n        } catch (e) {\n            return null;\n        }\n    };\n}\n\nif (typeof originalModule.findSymbolByName !== 'function') {\n    originalModule.findSymbolByName = function(moduleName, symbolName) {\n        if (moduleName === null) {\n            return originalModule.findGlobalExportByName(symbolName);\n        }\n        try {\n            const mod = Process.getModuleByName(moduleName);\n            return mod ? mod.findSymbolByName(moduleName) : null;\n        } catch (e) {\n            return null;\n        }\n    };\n}\n\nif (typeof originalModule.getSymbolByName !== 'function') {\n    originalModule.getSymbolByName = function(moduleName, symbolName) {\n        if (moduleName === null) {\n            return originalModule.getGlobalExportByName(symbolName);\n        }\n        try {\n            const mod = Process.getModuleByName(moduleName);\n            return mod ? mod.getSymbolByName(symbolName) : null;\n        } catch (e) {\n            return null;\n        }\n    };\n}\n\nif (typeof originalModule.getBaseAddress !== 'function') {\n    originalModule.getBaseAddress = function(moduleName) {\n        try {\n            return Process.getModuleByName(moduleName).base;\n        } catch (e) {\n            return null;\n        }\n    };\n}\n\nif (typeof originalModule.findBaseAddress !== 'function') {\n    originalModule.findBaseAddress = function(moduleName) {\n        try {\n            return Process.getModuleByName(moduleName).base;\n        } catch (e) {\n            return null;\n        }\n    };\n}\n\nif (typeof originalModule.ensureInitialized !== 'function') {\n    originalModule.ensureInitialized = function(moduleName) {\n        try {\n            Process.getModuleByName(moduleName).ensureInitialized();\n        } catch (e) {\n\n        }\n    };\n}\n\nconst originalMemory = _global.Memory;\n\nconst memoryReadMethods = [\n    'readPointer',\n    'readByteArray',\n    'readUtf8String',\n    'readUtf16String',\n    'readS8',\n    'readU8',\n    'readS16',\n    'readU16',\n    'readS32',\n    'readU32',\n    'readFloat',\n    'readDouble',\n    'readS64',\n    'readU64',\n    'readShort',\n    'readUShort',\n    'readInt',\n    'readUInt',\n    'readLong',\n    'readULong',\n    'readCString',\n    'readAnsiString',\n]\n\nmemoryReadMethods.forEach(function(methodName) {\n    if (typeof originalMemory[methodName] !== 'function') {\n        originalMemory[methodName] = function(targetPtr, ...args) {\n            const ptrObj = (targetPtr instanceof NativePointer) ? targetPtr : ptr(targetPtr);\n            return ptrObj[methodName](...args);\n        };\n    }\n});\n\nconst memoryWriteMethods = [\n    'writePointer',\n    'writeByteArray',\n    'writeUtf8String',\n    'writeUtf16String',\n    'writeS8',\n    'writeU8',\n    'writeS16',\n    'writeU16',\n    'writeS32',\n    'writeU32',\n    'writeFloat',\n    'writeDouble',\n    'writeS64',\n    'writeU64',\n    'writeShort',\n    'writeUShort',\n    'writeInt',\n    'writeUInt',\n    'writeLong',\n    'writeULong',\n    'writeCString',\n    'writeAnsiString',\n]\n\nmemoryWriteMethods.forEach(function(methodName) {\n    if (typeof originalMemory[methodName] !== 'function') {\n        originalMemory[methodName] = function(targetPtr, value, ...args) {\n            const ptrObj = (targetPtr instanceof NativePointer) ? targetPtr : ptr(targetPtr);\n            ptrObj[methodName](value, ...args);\n            return ptrObj;\n        };\n    }\n});\n\nif (typeof originalMemory.scanSync !== 'function' && typeof originalMemory.scan === 'function') {\n    originalMemory.scanSync = function(address, size, pattern) {\n        return originalMemory.scan(address, size, pattern);\n    }\n}\n\nconst namespaceOverrides = {\n    Process: {},\n    Kernel: {},\n};\n\nfunction buildEnumerationOverride(namespaceStr, methodName) {\n    const originalNamespace = _global[namespaceStr];\n    if (!originalNamespace[methodName]) return;\n\n    const originalMethod = originalNamespace[methodName];\n    if (!originalMethod) return;\n\n    const syncName = methodName + 'Sync';\n    namespaceOverrides[namespaceStr][syncName] = function(...args) {\n        return originalMethod.apply(originalNamespace, args);\n    }\n\n    namespaceOverrides[namespaceStr][methodName] = function(...args) {\n        const lastArg = args[args.length - 1];\n\n        if (lastArg && typeof lastArg === 'object' && typeof lastArg.onMatch === 'function') {\n            const nativeArgs = args.slice(0, args.length - 1);\n            const results = originalMethod.apply(originalNamespace, nativeArgs);\n\n            for (let i = 0; i < results.length; i++) {\n                const directive = lastArg.onMatch(results[i]);\n                if (directive === 'stop') break;\n            }\n            if (typeof lastArg.onComplete === 'function') lastArg.onComplete();\n            return;\n        } else {\n            return originalMethod.apply(originalNamespace, args);\n        }\n    }\n}\n\nbuildEnumerationOverride('Process', 'enumerateModules');\nbuildEnumerationOverride('Process', 'enumerateThreads');\nbuildEnumerationOverride('Process', 'enumerateRanges');\nbuildEnumerationOverride('Kernel', 'enumerateModules');\nbuildEnumerationOverride('Kernel', 'enumerateModuleRanges');\n\n['Process', 'Kernel'].forEach(function(ns) {\n    const original = _global[ns];\n    if (!original) return;\n\n    const overrides = namespaceOverrides[ns];\n\n    const proxyObj = new Proxy({}, {\n        get(target, prop) {\n            if (overrides.hasOwnProperty(prop)) return overrides[prop];\n            const value = original[prop];\n            if (typeof value === 'function') return value.bind(original);\n            return value;\n        },\n        set(target, prop, value) {\n            try {\n                original[prop] = value;\n            } catch (e) {\n\n            }\n            return true;\n        },\n        has(target, prop) {\n            return prop in overrides || prop in original;\n        },\n    });\n\n    try {\n        _global[ns] = proxyObj;\n    } catch (e) {\n        Object.defineProperty(_global, ns, { value: proxyObj, writable: true, configurable: true });\n    }\n});\n\nif (typeof originalModule.enumerateExports !== 'function') {\n    originalModule.enumerateExports = function(moduleName, callbacks) {\n        let mod;\n        try {\n            mod = Process.getModuleByName(moduleName);\n        } catch (e) {\n            return callbacks ? undefined : [];\n        }\n\n        const results = mod.enumerateExports();\n        if (callbacks && typeof callbacks.onMatch === 'function') {\n            for (let i = 0; i < results.length; i++) {\n                if (callbacks.onMatch(results[i]) === 'stop') break;\n                if (typeof callbacks.oncomplete === 'function') callbacks.oncomplete();\n            }\n        } else {\n            return results;\n        }\n    };\n}\n\nif (typeof originalModule.enumerateImports !== 'function') {\n    originalModule.enumerateImports = function(moduleName, callbacks) {\n        let mod;\n        try {\n            mod = Process.getModuleByName(moduleName);\n        } catch (e) {\n            return callbacks ? undefined : [];\n        }\n\n        const results = mod.enumerateImports();\n        if (callbacks && typeof callbacks.onMatch === 'function') {\n            for (let i = 0; i < results.length; i++) {\n                if (callbacks.onMatch(results[i]) === 'stop') break;\n                if (typeof callbacks.oncomplete === 'function') callbacks.oncomplete();\n            }\n        } else {\n            return results;\n        }\n    };\n}\n\nif (typeof originalModule.enumerateSymbols !== 'function') {\n    originalModule.enumerateSymbols = function(moduleName, callbacks) {\n        let mod;\n        try {\n            mod = Process.getModuleByName(moduleName);\n        } catch (e) {\n            return callbacks ? undefined : [];\n        }\n\n        const results = mod.enumerateSymbols();\n        if (callbacks && typeof callbacks.onMatch === 'function') {\n            for (let i = 0; i < results.length; i++) {\n                if (callbacks.onMatch(results[i]) === 'stop') break;\n                if (typeof callbacks.oncomplete === 'function') callbacks.oncomplete();\n            }\n        } else {\n            return results;\n        }\n    };\n}\n"
